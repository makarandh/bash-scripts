#!/bin/bash

################################################################
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
################################################################


print_help() {
    echo "Usage: $(basename ${0}) [-f] CLEANING_OPTION... DIR... "
    echo "$(basename ${0}) -h"
    echo "Cleans directories recurisively by deleting temporary, compiled, and downloaded modules."
    echo "Languages supported: Python, Gradle, Java, NodeJS, Php."
    echo -e "\nNOTE: It is not safe to provide the home directory as argument. \nThe script will exit if the argument is the user's home directory. \nTo force clean the home directory, use the -f switch."
    echo "The script may not be able to clean directories with spaces in their names."
    echo -e "\nCleaning options:"
    echo " -a           Will clean all files."
    echo " -y           Will clean Python files. Will delete .pyc files."
    echo " -j           Will clean Java files. Will delete .class and .jar files."
    echo " -g           Will clean Gradle projects. Will run gradlew clean."
    echo " -n           Will clean node files. Will delete node_modules folders and contents."
    echo " -p           Will clean PHP files. Will delete composer vendor folders and contents."

    echo -e "\nAdditional options:"
    echo " -f           Will clean user's home directory, if it's in the arguments."
    echo " -h           Will display this help and exit."
}

CLEAN_PY=0
CLEAN_JAVA=0
CLEAN_GRADLE=0
CLEAN_NODE=0
CLEAN_PHP=0
FORCE_HOME=0

OPTIONS_COUNT=0
while getopts ayjgnpfh OPTION
do
    let OPTIONS_COUNT++
    case ${OPTION} in
        "a")
            CLEAN_PY=1
            CLEAN_JAVA=1
            CLEAN_GRADLE=1
            CLEAN_NODE=1
            CLEAN_PHP=1
            ;;
        "y")
            CLEAN_PY=1
            ;;
        "j")
            CLEAN_JAVA=1
            ;;
        "g")
            CLEAN_GRADLE=1
            ;;
        "n")
            CLEAN_NODE=1
            ;;
        "p")
            CLEAN_PHP=1
            ;;
        "f")
            let OPTIONS_COUNT--
            FORCE_HOME=1
            ;;
        "h")
            print_help
            exit 0 
            ;;
        *)
            echo "ERROR: Invalid option: ${OPTION}"
            print_help
            exit 1
            ;;
    esac
done

if [[ ${OPTIONS_COUNT} -eq 0 ]]
then
	echo "Error: No cleaning options were provided."
    print_help
	exit 1
fi

shift $((${OPTIND} - 1))

if [[ ${#} -eq 0 ]]
then
	echo "Error: No directories were specified for cleaning."
    print_help
	exit 1
fi

declare -a ERROR_FILES
ERROR_COUNT=0

for DIR_TO_CLEAN in ${@}
do
    if [[ ! -d ${DIR_TO_CLEAN} ]]
    then
        echo "${DIR_TO_CLEAN} is not a directory. Skipping..."
        continue
    fi

    if [[ ${HOME} == $(cd "${DIR_TO_CLEAN}"; pwd) && ${FORCE_HOME} -eq 0 ]]
    then
        echo "Users Home directory selected without the -f option. Skipping..."
        continue
    fi
    DIR_TO_CLEAN=$(cd "${DIR_TO_CLEAN}"; pwd)
    ORIGINAL_DIR="${PWD}"
    echo -e "\nCleaning ${DIR_TO_CLEAN}"

    if [[ ${CLEAN_PY} -eq 1 ]]
    then
        echo -e "\nCleaning Python projects"
        echo -e "======================================================="

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_DEL
        do
            if [[ -f ${FILE_TO_DEL} ]]
            then
                echo "Deleting ${FILE_TO_DEL}"
                rm -f "${FILE_TO_DEL}"
            else
                echo "ERROR: Could not delete ${FILE_TO_DEL} --- Not a file"
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_DEL}"
                let ERROR_COUNT++
            fi
        done < <(find . -type f -name "*.pyc") 
        echo "Done"
        echo "-------------------------------------------------------"
    fi

    if [[ ${CLEAN_GRADLE} -eq 1 ]]
    then
        echo -e "\nCleaning Gradle projects"
        echo -e "======================================================="

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_CLEAN
        do
            if [[ -x ${FILE_TO_CLEAN} ]]
            then
                echo -e "\nGradle file found ${FILE_TO_CLEAN}"
                PROJ_DIR=$(dirname "${FILE_TO_CLEAN}")
                echo "Descending into ${PROJ_DIR}"
                cd "${PROJ_DIR}"
                ./gradlew clean
                cd "${ORIGINAL_DIR}"
                echo 
            else
                echo -e "ERROR: Could not clean gradle project: ${FILE_TO_CLEAN}."
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_CLEAN}"
                let ERROR_COUNT++
            fi
        done < <(find . -type f -name "*gradlew") 
        kill -15 $( ps -ef | grep -i "java" | grep -i "gradle" | tr -s " " | cut -d " " -f 2 ) 2> /dev/null
        echo "Done"
        echo "-------------------------------------------------------"
    fi

    if [[ ${CLEAN_JAVA} -eq 1 ]]
    then
        echo -e "\nCleaning Java projects"
        echo -e "======================================================="

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_DEL
        do
            if [[ -f ${FILE_TO_DEL} ]]
            then
                echo "Deleting ${FILE_TO_DEL}"
                rm -f "${FILE_TO_DEL}"
            else
                echo "ERROR: Could not delete ${FILE_TO_DEL} --- Not a file"
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_DEL}"
                let ERROR_COUNT++
            fi
        done < <(find . -type f -name "*class")

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_DEL
        do
            if [[ -f ${FILE_TO_DEL} ]]
            then
                echo "Deleting ${FILE_TO_DEL}"
                rm -f "${FILE_TO_DEL}"
            else
                echo "ERROR: Could not delete ${FILE_TO_DEL} --- Not a file"
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_DEL}"
                let ERROR_COUNT++
            fi
        done < <(find . -type f -iname "*jar" | grep 'out/artifacts')
        
        echo "Done"
        echo "-------------------------------------------------------"
    fi

    if [[ ${CLEAN_NODE} -eq 1 ]]
    then
        echo -e "\nCleaning node_modules"
        echo -e "======================================================="

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_DEL
        do
            if [[ ! -d $(echo ${FILE_TO_DEL} | sed 's/\/node_modules//g') ]]
            then
                continue
            fi

            if [[ -d ${FILE_TO_DEL} ]]
            then
                echo "Deleting ${FILE_TO_DEL}"
                rm -rf "${FILE_TO_DEL}"
            else
                echo "ERROR: Could not delete ${FILE_TO_DEL} --- Not a directory"
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_DEL}"
                let ERROR_COUNT++
            fi
        done < <(find . -type d -name "node_modules") 
        
        echo "Done"
        echo "-------------------------------------------------------"

    fi

    if [[ ${CLEAN_PHP} -eq 1 ]]
    then
        echo -e "\nCleaning php composer vendor files"
        echo -e "======================================================="

        cd "${DIR_TO_CLEAN}"
        while read FILE_TO_DEL
        do
            if [[ ! -f "$(echo ${FILE_TO_DEL} | sed 's/vendor//g')/composer.json" ]]
            then
                continue
            fi
            if [[ -d ${FILE_TO_DEL} ]]
            then
                echo "Deleting ${FILE_TO_DEL}"
                rm -rf "${FILE_TO_DEL}"
            else
                echo "ERROR: Could not delete ${FILE_TO_DEL} --- Not a directory"
                ERROR_FILES[${ERROR_COUNT}]="${FILE_TO_DEL}"
                let ERROR_COUNT++
            fi
        done < <(find . -type d -name "vendor")

        echo "Done"
        echo "-------------------------------------------------------"
    fi

done

if [[ ${ERROR_COUNT} -gt 0 ]]
then
    echo -e "\nSome files could not be cleaned and requires user action:"

    for((i=0; i<${ERROR_COUNT}; i++))
    do
        echo "${ERROR_FILES[i]}"
    done
    exit 2
fi

echo -e "\nAll requested files were successfully cleaned."
exit 0

